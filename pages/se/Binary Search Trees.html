<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
        rel="stylesheet">

    <link href="../../css/base.css" rel="stylesheet">
    <link href="../../css/lib.css" rel="stylesheet">
    <link href="../../css/common.css" rel="stylesheet">
    <link href="../../css/coms/com-nav.css" rel="stylesheet">
    <link href="../../css/coms/com-search.css" rel="stylesheet">
    <link href="../../css/coms/com-explore.css" rel="stylesheet">
    <link href="../../css/header.css" rel="stylesheet">
    <link href="../../css/footer.css" rel="stylesheet">

    <script src="../../js/search.js" type="text/javascript" defer></script>
    <script src="../../js/menu.js" type="text/javascript" defer></script>
    <title>Binary Search Trees</title>


</head>

<body class="searching">
    <header class="header null">
        <div class="logo null">
            <a href="../../index.html"><img src="../../images/base/logo2.png"></a>
        </div>
        <nav class="-lib--menu null" id="main-menu">
            <div class="-lib--menu-backdrop"></div>
            <div class="-lib--menu-body">
                <button class="-lib--menu-toggle -utils--position-btn" id="toggle-menu">
                    <i class="-utils--sr-only">toggle menu</i>
                </button>
                <div class="-lib--menu-dropdown null">
                    <ul class="nav-menu">
                        <li class="nav_fundamentals"><a href="../../pages/fu/fundamentals.html">Fundamentals</a></li>
                        <li class="nav_sorting"><a href="../../pages/so/sorting.html">Sorting</a></li>
                        <li class="nav_searching"><a href="../../pages/se/searching.html">Searching</a></li>
                        <li class="nav_graphs"><a href="../../pages/gr/graphs.html">Graphs</a></li>
                        <li class="nav_strings"><a href="../../pages/st/strings.html">Strings</a></li>
                    </ul>
                </div>
            </div>
        </nav>
        <div class="contact-us--icons null">
            <a href="https://github.com/"><img src="../../images/base/github-mark.png" alt="GitHub"></a>
            <a href="mailto:@gmail.com"><img src="../../images/base/email-mark.png" alt="Email"></a>
        </div>
    </header>
    <main class="">
        <div class="contents">
            <aside class="">
                <div class="topicpath null">
                    <ol>
                        <li class="topicpath-icon"><span>&nbsp;</span></li>
                        <li><a class="underline" href="../../index.html">Home</a>&nbsp;&gt;</li>
                        <li><a class="underline" href="./searching.html">Searching</a>&nbsp;&gt;</li>
                        <!-- <li>Bags, Queues, and Stacks</li> -->
                    </ol>
                </div>
                <!-- <div>>>>>>>>>>>>>>>>>>>>>>>>>>>>></div> -->
                <ul class="sub-nav ">
                    <!-- <li><a href="">Fundamentals</a>
                    <ol> -->
                    <li><a href="./Elementary Symbol Tables.html">
                            <div class="icon-container ">&nbsp;
                            </div>
                            <div class="">
                                <span>Elementary Symbol Tables</span>
                            </div>
                        </a></li>
                    <li class="sub-nav-current"><a href="./Binary Search Trees.html">
                            <div class="icon-container ">&nbsp;
                            </div>
                            <div class="">
                                <span>Binary Search Trees</span>
                            </div>
                        </a></li>
                    <li><a href="./Balanced Search Trees.html">
                            <div class="icon-container ">&nbsp;
                            </div>
                            <div class="">
                                <span>Balanced Search Trees</span>
                            </div>
                        </a></li>
                    <li><a href="./Hash Tables.html">
                            <div class="icon-container ">&nbsp;
                            </div>
                            <div class="">
                                <span>Hash Tables</span>
                            </div>
                        </a></li>
                    <!-- </ol>
                    </li> -->
                </ul>
            </aside>
            <article>
                <section class="section">
                    <div class="section-container ">
                        <div class="section-title chapter-title">
                            <h1>Binary Search Trees</h1>
                        </div>
                        <div class="section-content chapter-content">
                            <p>
                                We examine a symbol-table implementation that combines the 
                                flexibility of insertion in linked lists with the efficiency
                                of search in an ordered array.
                                Specifically, using two links per node
                                leads to an efficient symbol-table implementation based
                                on the binary search tree data structure, which qualifies as one of the most fundamental
                                algorithms in computer science.
                            </p>
                            <p>
                                <b>Definition.</b> A <em>binary search tree</em> (BST) is a binary 
                                tree where each node has a <code>Comparable</code> key
                                (and an associated value) and satisfies the restriction 
                                that the key in any node is larger than the keys in all
                                nodes in that node's left subtree and smaller than the keys
                                in all nodes in that node's right subtree.
                            </p>
                            <blockquote>
                                <TABLE BORDER = 0 CELLPADDING =2 CELLSPACING = 0>
                                    <tr>
                                        <td><IMG SRC="../../images/pages/se/32bst/binary-tree-anatomy.png" alt = "Anatomy of a binary tree">
                                        <td>
                                        &nbsp;&nbsp;&nbsp;&nbsp;
                                        &nbsp;&nbsp;&nbsp;&nbsp;
                                        &nbsp;&nbsp;&nbsp;&nbsp;
                                        <td><IMG SRC="../../images/pages/se/32bst/bst-anatomy.png" alt = "Anatomy of a binary search tree">
                                    </tr>
                                </table>
                            </blockquote>
                        </div>
                    </div>
                </section>
                <section class="section">
                    <div class="section-container">
                        <div class="section-title">
                            <h2 class="">&sect;&nbsp;Basic implementation.</h2>
                        </div>
                        <div class="section-content">
                            <p>
                                Program <a href = "BST.java.html">BST.java</a> implements
                                the ordered symbol-table API using a binary search tree.
                                We define a inner private class to define nodes in BST.
                                Each node contains a key, a value, a left link, a right link, and a node count.
                                The left link points to a BST for 
                                items with smaller keys, and the right link points to a BST for items with
                                larger keys. The instance variable <code>N</code> gives the node count
                                in the subtree rooted at the node. This field facilitates the implementation
                                of various ordered symbol-table operations, as you will see. 
                            </p>  
                            <p class="container--aligncenter">
                                <IMG SRC="../../images/pages/se/32bst/bst-subtree-count.png"  alt = "Subtree counts in a BST">
                            </p>
                                
                                
                            <ul>
                                <li><em>Search.</em>
                                    A recursive algorithm to search for a key in a BST
                                    follows immediately from the recursive structure: If the tree is 
                                    empty, we have a search miss; if the search key is equal to the key at the root, we have a 
                                    search hit. Otherwise, we search (recursively) in the appropriate subtree.
                                    The recursive <code>get()</code> method implements this algorithm directly.
                                    It takes a node (root of a subtree) as 
                                    first argument and a key as second argument, starting
                                    with the root of the tree and the search key.
                                
                                    <p class="container--aligncenter">
                                        <IMG SRC="../../images/pages/se/32bst/bst-search.png"  alt = "Search in a BST">
                                    </p>
                                <li><em>Insert.</em>
                                    Insert is not much more difficult to implement than search.
                                    Indeed, a search for a key not in the tree ends 
                                    at a null link, and all that we need to do is replace that link with a
                                    new node containing the key.
                                    The recursive <code>put()</code> method
                                    accomplishes this task using logic similar to that we used for the
                                    recursive search: If the tree is empty, we return a new node
                                    containing the key and value; if the search key is less 
                                    than the key at the root, we set the left link to the result
                                    of inserting the key into the left subtree; otherwise,
                                    we set the right link to the result of inserting the key into the right subtree.
                                    <p class="container--aligncenter">
                                        <IMG SRC="../../images/pages/se/32bst/bst-insert.png"  alt = "Insert in a BST">
                                    </p>
                                </ul>
                        </div>
                    </div>
                </section>
                <section class="section">
                    <div class="section-container">
                        <div class="section-title">
                            <h2 class="">&sect;&nbsp;Analysis.</h2>
                        </div>
                        <div class="section-content">
                            <p>
                                The running times of algorithms on binary search trees depend on the 
                                shapes of the trees, which, in turn, depends on the order in which keys are inserted.
                            </p>
                            <blockquote>
                                <TABLE BORDER = 0 CELLPADDING =2 CELLSPACING = 0>
                                    <tr>
                                        <td><IMG SRC="../../images/pages/se/32bst/bst-best.png" alt = "Best case for BST">
                                        <td>
                                        &nbsp;&nbsp;&nbsp;&nbsp;
                                        &nbsp;&nbsp;&nbsp;&nbsp;
                                        &nbsp;&nbsp;&nbsp;&nbsp;
                                        <td><IMG SRC="../../images/pages/se/32bst/bst-typical.png" alt = "Typical case for BST">
                                        &nbsp;&nbsp;&nbsp;&nbsp;
                                        &nbsp;&nbsp;&nbsp;&nbsp;
                                        &nbsp;&nbsp;&nbsp;&nbsp;
                                        <td><IMG SRC="../../images/pages/se/32bst/bst-worst.png" alt = "Worst case for BST">
                                    </tr>
                                </table>
                            </blockquote>
                            <p>
                                It is reasonable, for many applications, to use the following 
                                simple model: We assume that the keys are (uniformly) random, or,
                                equivalently, that they are inserted in random order.
                            </p>       
                               
                                
                               
                        </div>
                    </div>
                </section>
                <section class="section">
                    <div class="section-container">
                        <div class="section-title">
                            <h3 class=""><img src="../../images/base/paper-clip.png">&nbsp;Proposition.</h3>
                        </div>
                        <div class="section-content">
                            <p>Search hits in a BST built from N random keys
                               requires ~ 2 ln N (about 1.39 lg N) compares on the average.
                            </p>
                        </div>
                    </div>
                </section>
                <section class="section">
                    <div class="section-container">
                        <div class="section-title">
                            <h3 class=""><img src="../../images/base/paper-clip.png">&nbsp;Proposition.</h3>
                        </div>
                        <div class="section-content">
                            <p>
                                Insertion and search misses in a BST built
                                from N random keys requires ~ 2 ln N (about 1.39 lg N) compares on the average.
                            </p>  
                            <p>
                                The visualization below shows the result of inserting 255 keys in a BST in random order.
                                It displays the number of keys (N),
                                the maximum number of nodes on a path from the root to a leaf (max),
                                the average number of nodes on a path from the root to a leaf (avg),
                                the average number of nodes on a path from the root to a leaf in a perfectly 
                                balanced BST (opt).
                            </p> 
                            <blockquote>
                                <video controls="controls" width="630"
                                       name="Insert 255 keys in a BST in random order"
                                       poster="media/bst-255random.jpg"
                                       src="media/bst-255random.mov">
                                Your browser does not support the video tag.
                                </video>
                            </blockquote>
                        </div>
                    </div>
                </section>
                <section class="section">
                    <div class="section-container">
                        <div class="section-title">
                            <h2 class="">&sect;&nbsp;Order-based methods and deletion.</h2>
                        </div>
                        <div class="section-content">
                            <p>
                                An important reason that BSTs are widely used is that
                                they allow us to keep the keys <em>in order</em>. 
                                As such, they can serve as the basis for implementing the
                                numerous methods in our ordered symbol-table API.
                            </p>    
                            <ul>
                                <li><em>Minimum and maximum.</em>
                                    If the left link of the root is null, the smallest key in a BST is the key at the root;
                                    if the left link is not null, the smallest key in the BST is
                                    the smallest key in the subtree rooted at the node referenced by the left link.
                                    Finding the maximum key is similar, moving to the right instead of to the left.
                                
                                <li><em>Floor and ceiling.</em>
                                    If a given key key is less than the key at the root of a BST, then the 
                                    floor of key (the largest key in the BST less than or equal to key)
                                    <em>must</em> be in the left subtree.
                                    If key is greater than the key at the root, then the floor of key <em>could</em>
                                    be in the right subtree, but only if there is a key smaller than or equal to key
                                    in the right subtree; 
                                    if not (or if key is equal to the key at the root) then the key at the root
                                    is the floor of key.
                                    Finding the ceiling is similar, interchanging right and left.
                                
                                <li><em>Selection.</em>
                                    Suppose that we seek the key of rank <em>k</em>
                                    (the key such that precisely <em>k</em> other keys in the BST are smaller).
                                    If the number of keys <em>t</em> in the left subtree is larger than <em>k</em>,
                                    we look (recursively) for the key of rank <code>k</code> in the left subtree;
                                    if <em>t</em> is equal to <em>k</em>, we return the key at the root;
                                    and if <em>t</em> is smaller than <em>k</em>, we look (recursively) for the 
                                    key of rank <em>k - t - 1</em> in the right subtree.
                                    <blockquote>
                                    <TABLE BORDER = 0 CELLPADDING =2 CELLSPACING = 0>
                                        <tr>
                                            <td><IMG SRC="../../images/pages/se/32bst/bst-floor.png" alt = "Floor in a BST">
                                            <td>
                                            &nbsp;&nbsp;&nbsp;&nbsp;
                                            &nbsp;&nbsp;&nbsp;&nbsp;
                                            &nbsp;&nbsp;&nbsp;&nbsp;
                                            &nbsp;&nbsp;&nbsp;&nbsp;
                                            <td><IMG SRC="../../images/pages/se/32bst/bst-select.png" alt = "Selection in a BST">
                                        </tr>
                                    </table>
                                    </blockquote>
                                <li><em>Rank.</em>
                                    If the given key is equal to the key at the root, we return the number of keys
                                    <em>t</em> in the left subtree; if the given key is less than the key at the root,
                                    we return the rank of the key in the left 
                                    subtree; and if the given key is larger than the key
                                    at the root, we return <em>t</em> plus one (to count the key at the root)
                                    plus the rank of the key in the right subtree.
                                
                                <li><em>Delete the minimum and maximum.</em>
                                    For delete the minimum, we go left 
                                    until finding a node that that has a null left link and then replace
                                    the link to that node by its right link.
                                    The symmetric method works for delete the maximum.
                                
                                <li><em>Delete.</em>
                                    We can proceed in a similar manner to delete any node that has one child (or no children), 
                                    but what can we do to delete a node that has two children?
                                    We are left with two links, but have a place in the parent node for only one of them.
                                    An answer to this dilemma, first proposed by T. Hibbard in 1962,
                                    is to delete a node x by replacing it with its <em>successor</em>. 
                                    Because <code>x</code> has a right child, its successor is the node with the smallest
                                    key in its right subtree.
                                    The replacement preserves order in the tree because there are no keys between <code>x.key</code>
                                    and the successor's key.
                                    We accomplish the task of replacing <t>x</code> by its successor in four (!) easy steps:
                                    <ul>
                                        <li> Save a link to the node to be deleted in <code>t</code>
                                        <li> Set <code>x</code> to point to its successor <code>min(t.right)</code>.
                                        <li> Set the right link of <code>x</code> (which is supposed to point to the
                                            BST containing all the keys larger than <code>x.key</code>) to <code>deleteMin(t.right)</code>,
                                            the link to the BST containing all the keys that are larger than <code>x.key</code> after the deletion.
                                        <li> Set the left link of <code>x</code> (which was null) to <code>t.left</code>
                                            (all the keys that are less than both the deleted key and its successor).
                                    </ul>
                                    <blockquote>
                                    <TABLE BORDER = 0 CELLPADDING =2 CELLSPACING = 0>
                                        <tr>
                                            <td><IMG SRC="../../images/pages/se/32bst/bst-deletemin.png" alt = "Delete the min in a BST">
                                            <td>
                                            &nbsp;&nbsp;&nbsp;&nbsp;
                                            &nbsp;&nbsp;&nbsp;&nbsp;
                                            &nbsp;&nbsp;&nbsp;&nbsp;
                                            &nbsp;&nbsp;&nbsp;&nbsp;
                                            <td><IMG SRC="../../images/pages/se/32bst/bst-delete.png" alt = "Hibbard deletion in a BST">
                                        </tr>
                                    </table>
                                    </blockquote>
                                    <p>
                                        While this method does the job, it has a flaw that might cause
                                        performance problems in some practical 
                                        situations. The problem is that the choice of using the successor is arbitrary
                                        and not symmetric. Why not use the predecessor?
                                    </p>
                                    <p>
                                        <em>Each BST contains 150 nodes. We then repeatedly delete (via Hibbard deletion)
                                        and insert keys at random. The BST becomes skewed toward the left.</em>
                                    </p>
                                    <blockquote>
                                        <video controls="controls" width="630"
                                            name="Insert 150 keys into a BST then repeatedly delete and reinsert"
                                            poster="media/jibbard-150random.jpg"
                                            src="media/hibbard-150random.mov">
                                            Your browser does not support the video tag.
                                        </video>
                                    </blockquote>
                                <li><em>Range search.</em>
                                    To implement the <code>keys()</code> method that returns the keys in a given range,
                                    we begin with a basic recursive BST traversal method, known as <em>inorder</em> traversal.
                                    To illustrate the method, we 
                                    consider the task of printing all the keys in a BST in order. To do so, print all the keys in 
                                    the left subtree (which are less than the key at the root by
                                    definition of BSTs),
                                    then print the key at the root, then print all the keys in the right subtree,
                                    (which are greater than the key at the root by definition of BSTs).
                                    
                                    <blockquote>
                                        <div class="container">
<pre class="sourcecode">
private void print(Node x) {
if (x == null) return;
print(x.left);
StdOut.println(x.key);
print(x.right);
}
</pre>
                                        </div>
                                    </blockquote>
                                    <p>
                                        To implement the two-argument <code>keys()</code> method,
                                        we modify this code to add each key that is in the range to a <code>Queue</code>, and to 
                                        skip the recursive calls for subtrees that cannot contain keys in the range.
                                    </p>
                                </ul>
                        </div>
                    </div>
                </section>
                <section class="section">
                    <div class="section-container">
                        <div class="section-title">
                            <h3 class=""><img src="../../images/base/paper-clip.png">&nbsp;Proposition.</h3>
                        </div>
                        <div class="section-content">
                            <p>
                                Search, insertion, finding the minimum, finding the maximum, floor, ceiling, 
                                rank, select, delete the minimum, delete the maximum, delete, and range count operations all 
                                take time proportional to the height of the tree, in the worst case.
                            </p>
                        </div>
                    </div>
                </section>
            </article>
        </div>
    </main>
    <footer class="footer">
        <div class="footer__inner">
            <small>Copyright &copy; 2024 Yang, Inc.</small>
        </div>
    </footer>
</body>

</html>
