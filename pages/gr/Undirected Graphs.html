<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
        rel="stylesheet">

    <link href="../../css/base.css" rel="stylesheet">
    <link href="../../css/lib.css" rel="stylesheet">
    <link href="../../css/common.css" rel="stylesheet">
    <link href="../../css/coms/com-nav.css" rel="stylesheet">
    <link href="../../css/coms/com-search.css" rel="stylesheet">
    <link href="../../css/coms/com-explore.css" rel="stylesheet">
    <link href="../../css/header.css" rel="stylesheet">
    <link href="../../css/footer.css" rel="stylesheet">

    <script src="../../js/search.js" type="text/javascript" defer></script>
    <script src="../../js/menu.js" type="text/javascript" defer></script>
    <title>Undirected Graphs</title>


</head>

<body class="graphs">
    <header class="header null">
        <div class="logo null">
            <a href="../../index.html"><img src="../../images/base/logo2.png"></a>
        </div>
        <nav class="-lib--menu null" id="main-menu">
            <div class="-lib--menu-backdrop"></div>
            <div class="-lib--menu-body">
                <button class="-lib--menu-toggle -utils--position-btn" id="toggle-menu">
                    <i class="-utils--sr-only">toggle menu</i>
                </button>
                <div class="-lib--menu-dropdown null">
                    <ul class="nav-menu">
                        <li class="nav_fundamentals"><a href="../../pages/fu/fundamentals.html">Fundamentals</a></li>
                        <li class="nav_sorting"><a href="../../pages/so/sorting.html">Sorting</a></li>
                        <li class="nav_searching"><a href="../../pages/se/searching.html">Searching</a></li>
                        <li class="nav_graphs"><a href="../../pages/gr/graphs.html">Graphs</a></li>
                        <li class="nav_strings"><a href="../../pages/st/strings.html">Strings</a></li>
                    </ul>
                </div>
            </div>
        </nav>
        <div class="contact-us--icons null">
            <a href="https://github.com/"><img src="../../images/base/github-mark.png" alt="GitHub"></a>
            <a href="mailto:@gmail.com"><img src="../../images/base/email-mark.png" alt="Email"></a>
        </div>
    </header>
    <main class="">
        <div class="contents">
            <aside class="">
                <div class="topicpath null">
                    <ol>
                        <li class="topicpath-icon"><span>&nbsp;</span></li>
                        <li><a class="underline" href="../../index.html">Home</a>&nbsp;&gt;</li>
                        <li><a class="underline" href="./graphs.html">Graphs</a>&nbsp;&gt;</li>
                        <!-- <li>Bags, Queues, and Stacks</li> -->
                    </ol>
                </div>
                <!-- <div>>>>>>>>>>>>>>>>>>>>>>>>>>>>></div> -->
                <ul class="sub-nav ">
                    <!-- <li><a href="">Fundamentals</a>
                    <ol> -->
                    <li class="sub-nav-current"><a href="./Undirected Graphs.html">
                            <div class="icon-container ">&nbsp;
                            </div>
                            <div class="">
                                <span>Undirected Graphs</span>
                            </div>
                        </a></li>

                    <li><a href="./Directed Graphs.html">
                            <div class="icon-container ">&nbsp;
                            </div>
                            <div class="">
                                <span>Directed Graphs</span>
                            </div>
                        </a></li>
                    <li><a href="./Minimum Spanning Trees.html">
                            <div class="icon-container ">&nbsp;
                            </div>
                            <div class="">
                                <span>Minimum Spanning Trees</span>
                            </div>
                        </a></li>
                    <li><a href="./Shortest Paths.html">
                            <div class="icon-container ">&nbsp;
                            </div>
                            <div class="">
                                <span>Shortest Paths</span>
                            </div>
                        </a></li>
                    <!-- </ol>
                    </li> -->
                </ul>
            </aside>
            <article>
                <section class="section">
                    <div class="section-container ">
                        <div class="section-title chapter-title">
                            <h1>Undirected Graphs</h1>
                        </div>
                        <div class="section-content chapter-content">
                            
                        </div>
                    </div>
                </section>
                <section class="section">
                    <div class="section-container">
                        <div class="section-title">
                            <h2 class="">&sect;&nbsp;Graphs.</h2>
                        </div>
                        <div class="section-content">
                            <p>
                                A <em>graph</em> is a set of <em>vertices</em> and a collection
                                of <em>edges</em> that each connect a pair of vertices.
                                We use the names 0 through V-1 for the vertices in a V-vertex graph.
                            </p>
                            <p class="container--aligncenter">
                                <img src="../../images/pages/gr/41graph/graph.png" alt = "Graph">
                            </p>
                        </div>
                    </div>
                </section>
                <section class="section">
                    <div class="section-container">
                        <div class="section-title">
                            <h2 class="">&sect;&nbsp;Glossary.</h2>
                        </div>
                        <div class="section-content">
                            Here are some definitions that we use.
                            <ul>
                                <li> 
                                    A <em>self-loop</em> is an edge that connects a vertex to itself.
                                
                                <li>
                                    Two edges are <em>parallel</em> if they connect the same pair of
                                    vertices.
                                
                                <li>
                                    When an edge connects two vertices, we say that the vertices are
                                    <em>adjacent to</em> one another and that the edge is 
                                    <em>incident on</em> both vertices.
                                
                                <li>
                                    The <em>degree</em> of a vertex is the number of edges incident on it.
                                
                                <li>
                                    A <em>subgraph</em> is a subset of a graph's edges (and associated
                                    vertices) that constitutes a graph.
                                
                                <li>
                                    A <em>path</em> in a graph is a sequence of vertices connected by edges,
                                    with no repeated edges.
                                
                                <li>
                                    A <em>simple path</em> is a path with no repeated vertices.
                                
                                <li>
                                    A <em>cycle</em> is a path (with at least one edge)
                                    whose first and last vertices are the same.
                                
                                <li>
                                    A <em>simple cycle</em> is a cycle with no repeated vertices
                                    (other than the requisite repetition of the first and last vertices).
                                
                                <li>
                                    The <em>length</em> of a path or a cycle is its number of edges.
                                
                                <li>
                                    We say that one vertex is <em>connected to</em> another if there
                                    exists a path that contains both of them.
                                
                                <li>
                                    A graph is <em>connected</em> if there is a path from every vertex to
                                    every other vertex.
                                
                                <li>
                                    A graph that is not connected consists of a set of
                                    <em>connected components</em>, which are maximal connected subgraphs.
                                
                                <li>
                                    An <em>acyclic graph</em> is a graph with no cycles.
                                
                                <li>
                                    A <em>tree</em> is an acyclic connected graph.
                                
                                <li>
                                    A <em>forest</em> is a disjoint set of trees.
                                
                                <li>
                                    A <em>spanning tree</em> of a connected graph is a subgraph that
                                    contains all of that graph's vertices and is a single tree.
                                    A <em>spanning forest</em> of a graph is the union of the spanning
                                    trees of its connected components.
                                
                                <li>
                                    A <em>bipartite graph</em> is a graph whose vertices we can divide
                                    into two sets such that all edges connect a vertex in one set with a vertex
                                    in the other set.
                            </ul>
                            <p class="container--aligncenter">
                                <img src="../../images/pages/gr/41graph/graph-anatomy.png" alt="Anatomy of a Graph">
                                <img src="../../images/pages/gr/41graph/tree.png" alt="A tree">
                                <img src="../../images/pages/gr/41graph/forest.png" alt="A spanning forest">
                            </p>
                        </div>
                    </div>
                </section>
                <section class="section">
                    <div class="section-container">
                        <div class="section-title">
                            <h2 class="">&sect;&nbsp;Undirected graph data type.</h2>
                        </div>
                        <div class="section-content">
                            We implement the following undirected graph API.
                            <p class="container--aligncenter">
                                <img src="../../images/pages/gr/41graph/graph-api.png" alt = "Graph API">
                            </p>
                            <p>
                                The key method <code>adj()</code> allows client code
                                to iterate through the vertices adjacent to a given
                                vertex. Remarkably, we can build all of the algorithms that we
                                consider in this section on the basic abstraction embodied in <code>adj()</code>. 
                            </p>
                            <p>
                                We prepare the test data <a href = "tinyG.txt">tinyG.txt</a>,
                                <a href = "mediumG.txt">mediumG.txt</a>, and
                                <a href = "largeG.txt">largeG.txt</a>, using the following
                                input file format.
                            </p>
                            <p class="container--aligncenter">
                                <img src="../../images/pages/gr/41graph/graph-input.png" alt = "Graph input format">
                            </p>
                            <p>
                                <a href = "GraphClient.java.html">GraphClient.java</a> contains
                                    typical graph-processing code.
                            </p>
                        </div>
                    </div>
                </section>
                <section class="section">
                    <div class="section-container">
                        <div class="section-title">
                            <h2 class="">&sect;&nbsp;Graph representation.</h2>
                        </div>
                        <div class="section-content">
                            <p>
                                We use the <em>adjacency-lists representation</em>, where we maintain
                                a vertex-indexed array of lists of the vertices connected by an edge
                                to each vertex.
                            </p>
                            <p class="container--aligncenter">
                                <img src="../../images/pages/gr/41graph/adjacency-lists.png" alt = "Adjacency-lists
                                        representation of an undirected graph">
                            </p>
                            <p>
                                <a href = "Graph.java.html">Graph.java</a>
                                        implements the graph API using the adjacency-lists representation.
                                <a href = "AdjMatrixGraph.java.html">AdjMatrixGraph.java</a>
                                        implements the same API using the adjacency-matrix representation.
                            </p>
                        </div>
                    </div>
                </section>
                <section class="section">
                    <div class="section-container">
                        <div class="section-title">
                            <h2 class="">&sect;&nbsp;Depth-first search.</h2>
                        </div>
                        <div class="section-content">
                            <p>
                                Depth-first search is a classic recursive method for systematically
                                examining each of the vertices and edges in a graph. To visit a vertex
                            </p>
                            <ul>
                                <li>Mark it as having been visited.
                                <li> Visit (recursively) all the vertices that are adjacent to it and
                                    that have not yet been marked.
                            </ul>
                            <a href = "DepthFirstSearch.java.html">DepthFirstSearch.java</a>
                                implements this approach and the following API:
                            <p class="container--aligncenter">
                                <img src="../../images/pages/gr/41graph/search-api.png" alt = "Search API">
                            </p>
                        </div>
                    </div>
                </section>
                <section class="section">
                    <div class="section-container">
                        <div class="section-title">
                            <h2 class="">&sect;&nbsp;Finding paths.</h2>
                        </div>
                        <div class="section-content">
                            <p>
                                It is easy to modify depth-first search to not only determine whether there
                                exists a path between two given vertices but to find such a path (if one exists).
                                We seek to implement the following API:
                            </p>
                            <p class="container--aligncenter">
                                <img src="../../images/pages/gr/41graph/paths-api.png" alt = "Paths API">
                            </p>
                            <p>
                                To accomplish this, we remember the edge <code>v-w</code> that takes us to each
                                vertex <code>w</code> for the <em>first</em> time by setting <code>edgeTo[w]</code>
                                to <code>v</code>. In other words, <code>v-w</code> is the last edge on the known
                                path from <t>s</code> to <code>w</code>. The result of the 
                                search is a tree rooted at the source; <code>edgeTo[]</code> is a parent-link
                                representation of that tree. 
                                <a href = "DepthFirstPaths.java.html">DepthFirstPaths.java</a>
                                implements this approach.
                            </p>
                        </div>
                    </div>
                </section>
                <section class="section">
                    <div class="section-container">
                        <div class="section-title">
                            <h2 class="">&sect;&nbsp;Breadth-first search.</h2>
                        </div>
                        <div class="section-content">
                            <p>
                                Depth-first search finds some path from a source vertex s to a target vertex v.
                                We are often interested in finding the <em>shortest</em> such path (one with 
                                a minimal number of edges). 
                                Breadth-first search is a classic method based on this goal.
                                To find a  shortest path from <code>s</code> to <code>v</code>,
                                we start at <code>s</code> and check for <code>v</code> among all the vertices that we can 
                                reach by following one edge, then we check for <code>v</code>
                                among all the vertices that we can reach from 
                                <code>s</code> by following two edges, and so forth.
                            </p>
                            <p>
                                To implement this strategy, we maintain a queue of all vertices that
                                have been marked but whose adjacency lists have not been checked.
                                We put the source vertex on the queue, then perform the following
                                steps until the queue is empty:
                            </p>
                            <ul>
                                <li> Remove the next vertex <code>v</code> from the queue.
                                <li> Put onto the queue all unmarked vertices that are adjacent to <code>v</code> and mark them.
                            </ul>
                            <p>
                                <a href = "BreadthFirstPaths.java.html">BreadthFirstPaths.java</a>
                                is an implementation of the <code>Paths</code> API that finds shortest paths.
                                It relies on <a href = "Queue.java.html">Queue.java</a> for the FIFO queue.
                            </p>
                        </div>
                    </div>
                </section>
                <section class="section">
                    <div class="section-container">
                        <div class="section-title">
                            <h2 class="">&sect;&nbsp;Connected components.</h2>
                        </div>
                        <div class="section-content">
                            <p>
                                Our next direct application of depth-first search is to 
                                find the connected components of a graph.
                                Recall from Section 1.5 that "is connected to" is an equivalence relation
                                that divides the vertices into equivalence classes (the connected components).
                                For this task, we define the following API:
                            </p>
                            <p class="container--aligncenter">
                                <img src="../../images/pages/gr/41graph/cc-api.png" alt = "Connected Components API">
                            </p>
                            <p>
                            <a href = "CC.java.html">CC.java</a>
                            uses DFS to implement this API.
                            <p>
                                <b>Proposition.</b> DFS marks all the vertices connected to a given source
                                in time proportional to the sum of their degrees and provides
                                clients with a path from 
                                a given source to any marked vertex in time proportional to its length.
                            </p>
                            <p>
                                <b>Proposition.</b> For any vertex <code>v</code> reachable from <code>s</code>,
                                BFS computes a shortest path from <code>s</code> to <code>v</code>
                                (no path from <code>s</code> to <code>v</code> has fewer edges).
                                BFS takes time proportional to V + E in the worst case.
                            </p>
                            <p>
                                <b>Proposition.</b> DFS uses preprocessing time and space proportional
                                to V + E to support constant-time connectivity queries in a graph.
                            </p>
                        </div>
                    </div>
                </section>
                <section class="section">
                    <div class="section-container">
                        <div class="section-title">
                            <h2 class="">&sect;&nbsp;More depth-first search applications.</h2>
                        </div>
                        <div class="section-content">
                            <p>
                                The problems that we have solved with DFS are fundamental.
                                Depth-first search can also be used to solve the following problems:
                            </p>
                            <ul>
                                <li><em>Cycle detection:</em> Is a given graph acyclic?
                                    <a href = "Cycle.java.html">Cycle.java</a> uses depth-first search
                                    to determine whether a graph has a cycle, and if so return one.
                                    It takes time proportional to V + E in the worst case.
                                
                                <li><em>Two-colorability:</em> Can the vertices of a given graph
                                    be assigned one of two colors in such a way that no edge connects
                                    vertices of the same color?
                                    <a href = "Bipartite.java.html">Bipartite.java</a> uses depth-first search
                                    to determine whether a graph has a bipartition; if so, return one;
                                    if not, return an odd-length cycle.
                                    It takes time proportional to V + E in the worst case.
                                
                                <li><em>Bridge:</em>
                                    A <em>bridge</em> (or <em>cut-edge</em>) is an edge whose deletion increases 
                                    the number of connected components. Equivalently, an edge is a bridge if and only 
                                    if it is not contained in any cycle.
                                    <a href = "Bridge.java.html">Bridge.java</a>
                                    uses depth-first search to find time the bridges in a graph.
                                    It takes time proportional to V + E in the worst case.
                                
                                <li><em>Biconnectivity:</em>
                                    An <em>articulation vertex</em> (or <em>cut vertex</em>) is a vertex
                                    whose removal increases the number of connected components.
                                    A graph is <em>biconnected</em> if it has no articulation vertices.
                                    <a href = "Biconnected.java.html">Biconnected.java</a>
                                    uses depth-first search to find the bridges and articulation vertices.
                                    It takes time proportional to V + E in the worst case.
                                
                                <li><em>Planarity:</em>
                                    A graph is <em>planar</em> if it can be drawn in the plane such that no edges
                                    cross one another.  The Hopcroft-Tarjan algorithm is 
                                    an advanced application of depth-first search that determines
                                    whether a graph is planar in linear time.
                            </ul>
                        </div>
                    </div>
                </section>
                <section class="section">
                    <div class="section-container">
                        <div class="section-title">
                            <h2 class="">&sect;&nbsp;Symbol graphs.</h2>
                        </div>
                        <div class="section-content">
                            <p>
                                Typical applications involve processing graphs 
                                using strings, not integer indices, to define and refer to vertices.
                                To accommodate such 
                                applications, we define an input format with the following properties:
                            </p>
                            <ul>
                                <li>Vertex names are strings.
                                <li>A specified delimiter separates vertex names (to allow for the possibility of
                                    spaces in names).
                                <li>Each line represents a set of edges, connecting the first vertex
                                    name on the line to each of the other vertices named on the line.
                            </ul>
                            <p>
                                The input file <a href = "routes.txt">routes.txt</a> is a small example.
                            </p>
                            <blockquote>
                                <img src="../../images/pages/gr/41graph/routes.png" alt = "airline routes">
                            </blockquote>
                            <p>
                                The input file <a href = "movies.txt">movies.txt</a> is a larger example
                                from the <a href = "imdb.com">Internet Movie Database</a>.
                                This file consists of lines listing a movie name followed by a list of the
                                performers in the movie.
                            </p>
                            <blockquote>
                                <img src="../../images/pages/gr/41graph/movies.png" alt = "movie-performer graph">
                            </blockquote>
                            <ul>
                                <li><em>API.</em>
                                    The following API allows us to use our graph-processing routines for such input files.
                                    <blockquote>
                                        <img src="../../images/pages/gr/41graph/symbol-graph-api.png" alt = "symbol graph API">
                                    </blockquote>
                                
                                <li><em>Implementation.</em>
                                    <a href = "SymbolGraph.java.html">SymbolGraph.java</a> implements the API.
                                    It builds three data structures:
                                    <ul>
                                        <li> A symbol table <code>st</code> with <code>String</code> keys (vertex names)
                                        and <code>int</code> values (indices)
                                        
                                        <li> An array <code>keys[]</code> that serves as an inverted index,
                                        giving the vertex name associated with each integer index
                                        
                                        <li> A <code>Graph</code> <code>G</code> built using the indices to refer to vertices
                            
                                    </ul>
                                    <blockquote>
                                        <img src="../../images/pages/gr/41graph/symbol-graph.png" alt = "symbol graph data structures">
                                    </blockquote>
                            
                                <li><em>Degrees of separation.</em>
                                    <a href = "DegreesOfSeparation.java.html">DegreesOfSeparation.java</a>
                                    uses breadth-first search to find the degree of separation between
                                    two individuals in a social network. For the actor-movie graph, it plays 
                                    the Kevin Bacon game.
                            </ul>
                        </div>
                    </div>
                </section>
            </article>
        </div>
    </main>
    <footer class="footer">
        <div class="footer__inner">
            <small>Copyright &copy; 2024 Yang, Inc.</small>
        </div>
    </footer>
</body>

</html>
